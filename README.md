

### بخش 1: مقدمه به پایتون

1. آشنایی با پایتون
   - چرا پایتون؟
   - تاریخچه و کاربردهای پایتون
   - ویژگی‌های کلیدی پایتون
   - نصب پایتون و IDE ها (PyCharm, VS Code, Jupyter Notebook)
   - آشنایی با فریم‌ورک‌ها و کتابخانه‌های مشهور پایتون (Flask, Django, TensorFlow, PyTorch, FastAPI)
2. اولین برنامه در پایتون
   - نوشتن و اجرای اولین برنامه Hello World
   - آشنایی با سینتکس (Syntax) و نحوه نوشتن کد

------

### بخش 2: مفاهیم پایه در پایتون

1. **متغیرها و انواع داده‌ها**
   - تعریف متغیرها
   - انواع داده‌های پایه: عدد صحیح (Integer)، عدد اعشاری (Float)، رشته‌ها (String)، بولین‌ها (Boolean)
   - تبدیل نوع داده‌ها (Type Casting)
2. **عملگرها (Operators)**
   - عملگرهای ریاضی (+, -, *, /, %, //, **)
   - عملگرهای مقایسه‌ای (==, !=, >, <, >=, <=)
   - عملگرهای منطقی (and, or, not)
   - عملگرهای انتساب (=, +=, -=, *=, /=)
   - **عملگرهای زمان‌بندی**: استفاده از `time` module و `timeit` برای اندازه‌گیری زمان اجرای کد
3. **ساختارهای کنترلی**
   - شرطی‌ها (if, elif, else)
   - حلقه‌ها (for, while)
   - دستور break و continue

------



### بخش 3: توابع (Functions)

#### 1. **تعریف توابع**

- نحوه تعریف و استفاده از توابع
  - تعریف توابع با استفاده از کلمه کلیدی `def` در پایتون.
  - معرفی ساختار پایه تابع و فراخوانی آن.
  - مثال ساده از یک تابع که دو عدد را جمع می‌کند.
- پارامترها و مقادیر بازگشتی (Return)
  - تعریف پارامترهای تابع و نحوه استفاده از آن‌ها برای دریافت داده‌ها.
  - نحوه بازگشت مقادیر از تابع با استفاده از دستور `return`.
  - کاربرد `return` برای بازگشت بیش از یک مقدار (از طریق tuple).
- توابع بدون مقدار برگشتی
  - توابعی که مقدار بازگشتی ندارند و فقط عملیات خاصی انجام می‌دهند.
  - استفاده از `print` و اعمال تغییرات در متغیرهای خارجی در توابع بدون مقدار برگشتی.

#### 2. **توابع با تعداد متغیر ورودی متغیر (Arbitrary Arguments)**

- استفاده از *args*
  - توضیح در مورد پارامتر `*args` برای پذیرش تعداد نامحدودی از آرگومان‌ها.
  - نحوه استفاده از `*args` برای ارسال لیستی از مقادیر به تابع.
  - مثال از جمع کردن اعداد مختلف ارسال شده به تابع با استفاده از `*args`.
- **استفاده از kwargs
  - معرفی `**kwargs` برای ارسال آرگومان‌های کلید-مقدار به تابع.
  - توضیح نحوه استفاده از `**kwargs` برای دریافت تعداد نامحدود از آرگومان‌های کلید-مقدار.
  - مثال از ایجاد یک تابع که جزئیات مربوط به یک شخص (نام، سن، شغل) را دریافت کرده و چاپ کند.

#### 3. **توابع بازگشتی (Recursive Functions)**

- مفهوم بازگشتی
  - توضیح مفهوم بازگشت در توابع و استفاده از آن برای حل مسائل مشابه به طور خودکار.
  - بیان مثال‌هایی از توابع بازگشتی مثل محاسبه فاکتوریل یا دنباله فیبوناچی.
  - تعریف شرایط پایانی برای جلوگیری از حلقه‌های بی‌پایان.
- حل مسائل با استفاده از توابع بازگشتی
  - استفاده از توابع بازگشتی برای حل مسائل ساختاری مانند جستجو در درخت‌ها یا گراف‌ها.
  - مثال‌هایی از کاربرد بازگشتی در حل مسائل مرتب‌سازی و جستجو.
- بهینه‌سازی توابع بازگشتی
  - معرفی تکنیک‌هایی برای بهینه‌سازی توابع بازگشتی مانند **memoization**.
  - استفاده از دیکشنری برای ذخیره نتایج محاسبات قبلی در **memoization** به منظور کاهش پیچیدگی زمانی.
  - توضیح مفهوم **Tail Recursion** و تفاوت آن با سایر نوع‌های بازگشتی.

#### 4. **توابع Lambda (توابع ناشناس)**

- تعریف توابع Lambda
  - استفاده از توابع Lambda برای نوشتن توابع کوچک و بدون نیاز به تعریف جداگانه.
  - ساختار کلی توابع Lambda: `lambda arguments: expression`.
  - مثال از کاربرد Lambda برای انجام عملیات ساده مثل جمع دو عدد.
- استفاده از توابع Lambda در متدهای استاندارد
  - کاربرد توابع Lambda در متدهایی مانند `map()`, `filter()`, `sorted()`.
  - مثال از استفاده از Lambda برای فیلتر کردن لیستی از اعداد زوج.

#### 5. **توابع با مقادیر پیش‌فرض (Default Parameters)**

- تعریف پارامترهای پیش‌فرض
  - توضیح چگونگی استفاده از پارامترهای پیش‌فرض در توابع برای تعیین مقادیر اولیه.
  - بررسی رفتار پارامترهای پیش‌فرض زمانی که هیچ مقداری برای آن‌ها ارسال نمی‌شود.
- انتقال پارامترها و تأثیر بر متغیرهای پیش‌فرض
  - استفاده از پارامترهای پیش‌فرض با توجه به نیازهای خاص تابع.
  - مثال‌هایی از تغییرات در متغیرهای پیش‌فرض در داخل توابع.





------

### بخش 4: کار با داده‌ها (Data Structures)

1. **لیست‌ها (Lists)**
   - ایجاد و دسترسی به لیست‌ها
   - عملیات مختلف روی لیست‌ها: افزودن، حذف، تغییر مقدار
   - لیست‌های تو در تو (Nested Lists)
   - توابع کاربردی لیست‌ها: append(), extend(), remove(), pop(), sort()
2. **تاپل‌ها (Tuples)**
   - تعریف و تفاوت‌ها با لیست‌ها
   - استفاده از تاپل‌ها برای ذخیره داده‌های ثابت
3. **دیکشنری‌ها (Dictionaries)**
   - ایجاد و دسترسی به دیکشنری‌ها
   - عملیات مختلف روی دیکشنری‌ها: افزودن، حذف، دسترسی به کلیدها و مقادیر
   - توابع کاربردی دیکشنری‌ها: keys(), values(), items()
   - **استفاده از defaultdict**: مدیریت مقادیر پیش‌فرض با `collections.defaultdict`
4. **مجموعه‌ها (Sets)**
   - ایجاد و دسترسی به مجموعه‌ها
   - عملیات مختلف روی مجموعه‌ها: افزودن، حذف، تشخیص تکراری بودن
   - عملیات ریاضی روی مجموعه‌ها: اتحاد، اشتراک، تفاوت

------

### بخش 5: مدیریت فایل‌ها

#### 1. **خواندن و نوشتن در فایل‌ها**

- **نحوه باز کردن فایل‌ها:**
  - استفاده از تابع `open()`.
  - حالت‌های مختلف باز کردن فایل‌ها:
    - `r`: خواندن فایل (فایل باید وجود داشته باشد).
    - `w`: نوشتن در فایل (اگر فایل وجود نداشته باشد، جدیداً ساخته می‌شود).
    - `a`: اضافه کردن داده‌ها به انتهای فایل.
    - `rb`, `wb`: حالت باینری برای خواندن و نوشتن در فایل‌ها.
    - استفاده از `with` برای مدیریت خودکار منابع و بسته شدن فایل‌ها.
- **خواندن فایل‌ها:**
  - `read()`: خواندن تمام محتوای فایل.
  - `readline()`: خواندن یک خط از فایل.
  - `readlines()`: خواندن تمامی خطوط فایل به صورت لیست.
  - مثال‌هایی از پردازش داده‌ها هنگام خواندن فایل‌ها.
- **نوشتن در فایل‌ها:**
  - `write()`: نوشتن یک رشته در فایل.
  - `writelines()`: نوشتن لیستی از رشته‌ها به فایل.
  - تفاوت‌های نوشتن از ابتدا (حالت `w`) و افزودن به انتهای فایل (حالت `a`).
  - مثال‌هایی از نوشتن داده‌ها در فایل‌ها.

#### 2. **مدیریت استثناها و خطاها (Error Handling)**

- **استفاده از try, except, else, finally:**
  - استفاده از بلوک‌های `try` و `except` برای مدیریت خطاها.
  - توضیح بخش‌های else` و `finally
    - `else` برای اجرای کدی در صورت عدم وقوع استثنا.
    - `finally` برای انجام عملیات نهایی (مثل بستن فایل‌ها یا آزادسازی منابع).
  - مثال‌هایی از استفاده از این بلوک‌ها در مدیریت خطاهای فایل‌ها.
- **ایجاد استثناهای سفارشی با raise:**
  - نحوه استفاده از `raise` برای ایجاد استثناهای سفارشی.
  - تعریف استثناهای سفارشی با کلاس‌ها.
  - ارسال پیام‌های خطای مفید برای رفع اشکال.
  - مثال‌هایی از ایجاد و مدیریت استثناهای سفارشی.

#### 3. **نکات تکمیلی و شیوه‌های بهتر**

- **مدیریت فایل‌ها با استفاده از Context Manager (with):**
  - اهمیت استفاده از `with` برای بسته شدن خودکار فایل‌ها و جلوگیری از مشکلات منابع.
  - مثال‌هایی از استفاده از `with` برای باز کردن و بستن فایل‌ها.
- **استثناهای رایج در کار با فایل‌ها:**
  - مدیریت خطاهایی مثل `FileNotFoundError`، `PermissionError` و سایر استثناهای معمول در کار با فایل‌ها.
  - نحوه برخورد با خطاهای مختلف هنگام باز کردن، خواندن یا نوشتن در فایل.
- **نکات عملکردی و ایمنی در کار با فایل‌ها:**
  - احتیاط‌های لازم برای جلوگیری از از دست رفتن داده‌ها.
  - استفاده از روش‌های مناسب برای نوشتن به فایل به ویژه در موارد حساس.
  - بررسی صحت داده‌ها قبل از نوشتن به فایل.
- **مثال‌های کاربردی جامع:**
  - مثال‌هایی که روند خواندن داده از یک فایل، پردازش داده‌ها و نوشتن نتایج در فایل دیگری را نشان می‌دهد.
  - کار با فایل‌های متنی و باینری.

------

### بخش 6: کلاس‌ها و شی‌گرایی (OOP)

#### 1. **مبانی شی‌گرایی**

- مفهوم شیء و کلاس
  - تعریف شیء (Object) و کلاس (Class) و تفاوت‌های آنها.
  - شی‌گرایی به عنوان یک پارادایم برنامه‌نویسی.
  - مثال‌های عملی از نحوه استفاده از کلاس‌ها و اشیاء.
- تعریف کلاس‌ها و ساختار آنها
  - نحوه تعریف یک کلاس با استفاده از کلمه‌کلیدی `class`.
  - تعریف ویژگی‌ها (Attributes) و متدها (Methods) در کلاس‌ها.
  - تفاوت بین ویژگی‌ها و متدهای کلاس.
  - دسترسی به ویژگی‌ها و متدها با استفاده از شیء.
  - مثال‌های کاربردی از ایجاد کلاس‌ها و اشیاء.
- ویژگی‌ها و متدهای کلاس‌ها
  - تعریف و استفاده از ویژگی‌های کلاس (class attributes) و ویژگی‌های اشیاء (instance attributes).
  - تعریف و استفاده از متدهای کلاس و متدهای نمونه.
  - نحوه استفاده از `self` برای دسترسی به ویژگی‌ها و متدهای نمونه.

#### 2. **وراثت (Inheritance)**

- ارث‌بری در پایتون
  - معرفی مفهوم وراثت و نحوه استفاده از آن برای ایجاد سلسله‌مراتب کلاس‌ها.
  - نحوه ارث‌بری از یک کلاس پایه (Base class) و ایجاد کلاس‌های فرزند (Child class).
  - مزایای استفاده از وراثت در کدنویسی و کاهش تکرار کد.
  - مثال‌هایی از ارث‌بری ساده.
- متدهای ارثی و بازنویسی متدها (Overriding Methods)
  - نحوه بازنویسی متدهای کلاس پایه در کلاس‌های فرزند.
  - تفاوت بین ارث‌بری و بازنویسی (Overriding) متدها.
  - استفاده از متد `super()` برای فراخوانی متدهای کلاس پایه.
  - مثال‌هایی از بازنویسی متدها و کاربرد آن‌ها.

#### 3. **پلی‌مورفیسم (Polymorphism)**

- مفهوم پلی‌مورفیسم
  - تعریف پلی‌مورفیسم به معنای "چندشکلی" و نحوه استفاده از آن در شی‌گرایی.
  - تفاوت بین پلی‌مورفیسم در زمان کامپایل و زمان اجرا.
- استفاده از پلی‌مورفیسم در پایتون
  - نحوه پیاده‌سازی پلی‌مورفیسم با استفاده از متدهای مشترک در کلاس‌های مختلف.
  - مثال‌هایی از استفاده از پلی‌مورفیسم در پایتون.
  - ایجاد کدهایی که بسته به نوع شیء رفتارهای متفاوتی دارند.

#### 4. **انتزاع (Abstraction) و کپسوله‌سازی (Encapsulation)**

- انتزاع (Abstraction)
  - تعریف انتزاع به عنوان مخفی کردن پیچیدگی‌ها و نشان دادن فقط ویژگی‌های ضروری به کاربر.
  - استفاده از کلاس‌های انتزاعی (Abstract Classes) و متدهای انتزاعی (Abstract Methods) با استفاده از ماژول `abc`.
  - ایجاد و استفاده از کلاس‌ها و متدهای انتزاعی.
  - مثال‌هایی از پیاده‌سازی انتزاع در پایتون.
- کپسوله‌سازی (Encapsulation)
  - معرفی مفهوم کپسوله‌سازی به معنای پنهان‌سازی جزئیات داخلی و نمایش فقط رابط‌های عمومی.
  - استفاده از ویژگی‌ها و متدهای خصوصی و عمومی.
  - نحوه دسترسی به ویژگی‌ها و متدهای خصوصی با استفاده از قوانین `private` و `protected`.
  - استفاده از ویژگی‌های خصوصی با استفاده از دکوریتور `@property` و `@setter`.
  - مثال‌هایی از کپسوله‌سازی با استفاده از `private` و `@property`.

#### 5. **دستگاه‌های مدیریت ویژگی‌ها (Property Methods)**

- استفاده از دکوریتور `@property` برای تبدیل متدها به ویژگی‌ها.
- استفاده از `@setter` برای تغییر مقادیر ویژگی‌های خصوصی.
- مزایا و کاربردهای استفاده از `@property` و `@setter` در کپسوله‌سازی.

#### 6. **ترکیب (Composition)**

- مفهوم ترکیب به عنوان جایگزینی برای وراثت در بعضی از موارد.
- نحوه استفاده از ترکیب برای ایجاد کلاس‌هایی که وابسته به دیگر کلاس‌ها هستند بدون استفاده از وراثت.
- مثال‌هایی از استفاده ترکیب در پایتون.

#### 7. **مدیریت منابع و بستن اشیاء**

- استفاده از متد `__del__` برای پاکسازی و بستن منابع پس از پایان کار با شیء.
- مثال‌هایی از مدیریت منابع و بستن اشیاء به درستی.

#### 8. **نمونه‌های کاربردی**

- طراحی یک کلاس پیچیده با استفاده از تمام مفاهیم شی‌گرایی (وراثت، پلی‌مورفیسم، انتزاع و کپسوله‌سازی).
- استفاده از کلاس‌ها برای ساخت یک سیستم واقعی مانند مدیریت بانک، مدرسه یا فروشگاه.



------

### بخش 7: کتابخانه‌های استاندارد و مفید پایتون

#### 1. **کتابخانه os و sys**

- مدیریت مسیرها و فایل‌ها با `os`
  - دسترسی به اطلاعات سیستم‌عامل (مانند پوشه‌ها و فایل‌ها).
  - کار با مسیرهای فایل‌ها با استفاده از `os.path`.
  - ایجاد، حذف و تغییر نام فایل‌ها و دایرکتوری‌ها.
  - تغییر دایرکتوری کاری فعلی با `os.chdir()`.
  - جابجایی فایل‌ها و پوشه‌ها با `os.rename()` و `os.remove()`.
  - اجرای دستورات سیستم‌عامل با `os.system()`.
  - استفاده از `os.walk()` برای پیمایش دایرکتوری‌ها.
- استفاده از سیستم‌عامل و اطلاعات محیطی با `sys`
  - دسترسی به پارامترهای ورودی از خط فرمان با `sys.argv`.
  - مدیریت استثناها و خاتمه برنامه با `sys.exit()`.
  - استفاده از `sys.path` برای مدیریت مسیرهای جستجوی ماژول‌ها.
  - مشاهده اطلاعات سیستم‌عامل مانند نسخه پایتون با `sys.version`.

#### 2. **کتابخانه `datetime`**

- کار با تاریخ و زمان
  - تعریف و استفاده از شیء `datetime` برای کار با تاریخ و زمان.
  - نحوه بدست آوردن تاریخ و زمان فعلی با `datetime.now()`.
  - تبدیل تاریخ و زمان به رشته با استفاده از متد `strftime()`.
  - ایجاد تاریخ و زمان‌های خاص با `datetime()` و `timedelta()`.
  - تبدیل رشته به تاریخ با استفاده از `strptime()`.
- تبدیل بین فرمت‌های مختلف تاریخ و زمان
  - نحوه فرمت‌بندی تاریخ‌ها و زمان‌ها به فرمت‌های دلخواه.
  - استفاده از `strftime()` برای ایجاد فرمت‌های سفارشی.
  - تبدیل تاریخ‌ها و زمان‌ها به UTC و تبدیل آن به مناطق زمانی مختلف.

#### 3. **کتابخانه `math` و `random`**

- استفاده از توابع ریاضی پایه با `math`
  - توابع مختلف ریاضی مانند `sin()`, `cos()`, `tan()`, `sqrt()`, `log()`.
  - ثابت‌های ریاضی مانند `math.pi`, `math.e`.
  - استفاده از توابع مانند `ceil()`, `floor()` برای گرد کردن اعداد.
  - محاسبه توابع مثلثاتی و توابع نمایی.
  - استفاده از توابع پیشرفته مانند `gcd()` برای محاسبه بزرگترین مقسوم‌علیه مشترک.
- تولید اعداد تصادفی با `random`
  - تولید اعداد تصادفی با `random.randint()`, `random.choice()`, `random.uniform()`.
  - تولید توزیع‌های مختلف تصادفی مانند `random.normalvariate()`.
  - نمونه‌برداری از داده‌ها با `random.sample()` و `random.shuffle()`.

#### 4. **کتابخانه `collections`**

- استفاده از انواع داده‌های خاص
  - `Counter`
    - شمارش تعداد تکرار هر عنصر در یک داده.
    - استفاده از `most_common()` برای یافتن پر تکرارترین عناصر.
  - `deque`
    - استفاده از دنباله‌ها (Queues) برای افزودن و حذف سریع از دو طرف لیست.
    - مقایسه `deque` با لیست‌ها و مزایای آن.
  - `defaultdict`
    - استفاده از دیکشنری‌های پیش‌فرض برای جلوگیری از خطاهای دسترسی به کلیدهای غیرموجود.
    - مثال‌هایی از استفاده از `defaultdict` برای شمارش یا گروه‌بندی.
  - `namedtuple`
    - استفاده از `namedtuple` برای تعریف ساختارهای داده‌ای مشابه به کلاس‌ها با ویژگی‌های نامگذاری‌شده.
    - مقایسه `namedtuple` با دیکشنری‌ها و ساختارهای داده‌ای دیگر.
  - `OrderedDict`
    - استفاده از دیکشنری‌های مرتب‌شده برای حفظ ترتیب وارد کردن عناصر.

#### 5. **کتابخانه `json`**

- کار با داده‌های JSON
  - تبدیل داده‌های پایتون به فرمت JSON با استفاده از `json.dumps()`.
  - تبدیل داده‌های JSON به اشیاء پایتون با استفاده از `json.loads()`.
- تبدیل داده‌های Python به JSON و بالعکس
  - ذخیره و بارگذاری داده‌ها در/از فایل‌های JSON.
  - مثال‌هایی از تبدیل ساختارهای پیچیده مانند لیست‌ها و دیکشنری‌ها به JSON.
  - استفاده از گزینه‌های پیشرفته مانند `indent`, `sort_keys` برای فرمت‌بندی بهتر فایل JSON.
- استفاده از JSON برای ارتباط بین سیستم‌ها
  - کار با API‌ها و ارسال و دریافت داده‌های JSON از طریق HTTP.
  - بررسی امنیت داده‌های JSON و نحوه جلوگیری از آسیب‌پذیری‌ها در هنگام کار با داده‌ها.

#### 6. **کتابخانه `shutil`**

- کار با فایل‌ها و دایرکتوری‌ها
  - استفاده از `shutil.copy()` و `shutil.move()` برای کپی و جابجایی فایل‌ها.
  - فشرده‌سازی و استخراج فایل‌های ZIP با استفاده از `shutil.make_archive()` و `shutil.unpack_archive()`.
  - حذف دایرکتوری‌ها با `shutil.rmtree()`.

#### 7. **کتابخانه `itertools`**

- عملیات روی تکرارکننده‌ها
  - استفاده از `itertools.chain()` برای اتصال چندین تکرارکننده.
  - تولید ترکیب‌ها و ترتیب‌های مختلف با `itertools.combinations()` و `itertools.permutations()`.
  - استفاده از `itertools.product()` برای تولید ضرب داخلی (Cartesian Product).
  - مدیریت تکرارهای بی‌پایان با `itertools.cycle()` و `itertools.count()`.







------

### بخش 8: کار با پایگاه داده (Database)

#### 1. **اتصال به پایگاه داده SQL با SQLite**

- ایجاد و اتصال به پایگاه داده SQLite
  - نصب و راه‌اندازی SQLite در پایتون با استفاده از کتابخانه `sqlite3`.
  - ایجاد پایگاه داده جدید با استفاده از `sqlite3.connect()`.
  - اتصال به پایگاه داده موجود و مدیریت ارتباطات.
- انجام عملیات CRUD (Create, Read, Update, Delete)
  - **Create**: ایجاد جداول جدید با استفاده از دستور SQL `CREATE TABLE` و افزودن داده‌ها با `INSERT INTO`.
  - **Read**: خواندن داده‌ها از جداول با استفاده از `SELECT` و ذخیره نتایج در متغیرها با استفاده از متد `fetchone()` و `fetchall()`.
  - **Update**: به‌روزرسانی داده‌های موجود با استفاده از دستور SQL `UPDATE` و تعیین شرط با `WHERE`.
  - **Delete**: حذف داده‌ها با استفاده از دستور SQL `DELETE` و اعمال فیلترهای مناسب.
- استفاده از توابع و شرایط SQL در SQLite
  - استفاده از دستورات شرطی مانند `WHERE`, `AND`, `OR`, `IN`, `BETWEEN` در جستجو.
  - استفاده از توابع SQL مانند `COUNT()`, `SUM()`, `AVG()`, `MAX()`, `MIN()`.
- مدیریت تراکنش‌ها (Transactions)
  - استفاده از `commit()` برای ذخیره تغییرات و `rollback()` برای برگشت تغییرات.
  - مدیریت خطاها با استفاده از `try-except`.
- کار با داده‌های JSON در SQLite
  - ذخیره و بازیابی داده‌های JSON به‌طور مستقیم با استفاده از `json.dumps()` و `json.loads()`.

#### 2. **اتصال به پایگاه داده MySQL/PostgreSQL**

- نصب کتابخانه‌های مربوطه

  - **MySQL**: نصب کتابخانه `mysql-connector-python` یا `PyMySQL` برای اتصال به MySQL.
  - **PostgreSQL**: نصب کتابخانه `psycopg2` برای اتصال به PostgreSQL.
  - نصب کتابخانه‌های مربوطه از طریق `pip install mysql-connector-python` یا `pip install psycopg2`.

- اتصال به پایگاه داده MySQL/PostgreSQL

  - استفاده از `connect()` برای اتصال به پایگاه داده.
  - ارائه جزئیات اتصال مانند نام کاربری، رمز عبور، نام پایگاه داده و آدرس سرور.
  - مدیریت خطاهای اتصال با استفاده از `try-except`.

- انجام عملیات CRUD مشابه SQLite

  - انجام عملیات `CREATE`, `READ`, `UPDATE`, `DELETE` در پایگاه داده MySQL/PostgreSQL به‌صورت مشابه SQLite.
  - استفاده از دستورات SQL استاندارد برای انجام این عملیات.

- استفاده از اتصال از راه دور (Remote Connection)

  - اتصال به پایگاه داده‌های MySQL/PostgreSQL از راه دور (از طریق IP عمومی).
  - مدیریت اتصال به پایگاه داده‌های ابری.

- مدیریت تراکنش‌ها (Transactions) در MySQL/PostgreSQL

  - استفاده از `commit()` و `rollback()` برای مدیریت تراکنش‌ها در پایگاه داده.
  - بررسی و جلوگیری از شرایط تراکنش‌های ناتمام.

- استفاده از ORM (Object-Relational Mapping) با SQLAlchemy

  - معرفی SQLAlchemy برای انجام عملیات پایگاه داده با استفاده از شی‌گرایی.

  - نحوه نصب و راه‌اندازی SQLAlchemy.

  - ساخت کلاس‌ها و متدهای ORM برای تعامل با جداول.

  - استفاده از SQLAlchemy برای انجام عملیات CRUD بدون نوشتن دستورات SQL به صورت مستقیم.

  - مهاجرت‌های پایگاه داده (Alembic)

  - مدیریت داده‌های JSON و داده‌های پیچیده

  - **استفاده از دستورات RAW SQL**

  - **استفاده از Join‌ها و ارتباطات پیچیده**

  - استفاده از متدهای ویژه برای بهینه‌سازی پرس‌وجوها

  - مدیریت خطاها و استثناها (Advanced Error Handling)

  - تنظیمات پیشرفته Pooling (Connection Pooling)

    

- کار با داده‌های JSON در MySQL/PostgreSQL

  - ذخیره و بازیابی داده‌های JSON در MySQL/PostgreSQL.
  - استفاده از انواع داده‌های `JSON` در MySQL و `JSONB` در PostgreSQL.

#### 3. **دستورات پیشرفته SQL**

- استفاده از JOIN برای ترکیب جداول مختلف
  - `INNER JOIN`, `LEFT JOIN`, `RIGHT JOIN`, `FULL OUTER JOIN`.
  - کاربرد `ON` برای تعیین شرایط ترکیب.
- استفاده از GROUP BY و HAVING
  - گروه‌بندی داده‌ها با `GROUP BY`.
  - فیلتر داده‌ها پس از گروه‌بندی با `HAVING`.
- زیرپرسش‌ها (Subqueries)
  - استفاده از زیرپرسش‌ها برای انجام عملیات پیچیده در یک دستور SQL.
  - استفاده از `IN`, `EXISTS`, و `ANY` برای انجام عملیات پیچیده با زیرپرسش‌ها.

#### 4. **مدیریت امنیت پایگاه داده**

- مدیریت دسترسی‌ها و مجوزها
  - ایجاد کاربران و تخصیص مجوزهای مختلف به آن‌ها.
  - استفاده از `GRANT` و `REVOKE` برای تخصیص و لغو مجوزها.
- استفاده از رمزنگاری برای داده‌ها
  - رمزنگاری داده‌ها قبل از ذخیره‌سازی در پایگاه داده.
  - استفاده از فیلدهای رمزنگاری‌شده برای داده‌های حساس.









------

### بخش 9: برنامه‌نویسی همزمان (Concurrency)

#### 1. **مدیریت Threadها و Multiprocessing**

- ایجاد و مدیریت Thread

  - تعریف و تفاوت بین Thread و Process.

  - ایجاد و راه‌اندازی Threadها با استفاده از کتابخانه `threading`.

  - استفاده از متدهای `start()`, `join()`, و `is_alive()` برای کنترل اجرای Threadها.

  - استفاده از `ThreadPoolExecutor` برای مدیریت مجموعه‌ای از Threadها.

  - کار با مشکلات هم‌زمانی (Concurrency issues) مثل `race condition` و استفاده از `Lock`, `RLock`, `Semaphore` برای مدیریت دسترسی هم‌زمان به منابع.

  - استفاده از `Threading.Event` و `Condition` برای هماهنگی بین Threadها.

    

- استفاده از Multiprocessing برای انجام پردازش‌های موازی

  - تفاوت بین Multiprocessing و Threading در پایتون و استفاده از `multiprocessing` برای پردازش‌های موازی.
  - ایجاد و مدیریت `Process`ها با استفاده از کلاس `Process` در کتابخانه `multiprocessing`.
  - استفاده از `Queue` و `Pipe` برای ارسال داده بین Processها.
  - استفاده از `Pool` برای اجرای پردازش‌ها به‌صورت موازی در مجموعه‌ای از پردازش‌ها.
  - مقایسه عملکرد و بهینه‌سازی استفاده از `Threading` و `Multiprocessing` در پایتون.

#### 2. **استفاده از Asyncio**

- **برنامه‌نویسی غیرهمزمان با asyncio**:
  - مفهوم برنامه‌نویسی غیرهمزمان و تفاوت آن با برنامه‌نویسی همزمان.
  - معرفی کتابخانه `asyncio` برای مدیریت عملیات غیرهمزمان.
  - تعریف `Event Loop` و نحوه اجرای آن.
  - تفاوت بین `Threading`, `Multiprocessing` و `Asyncio` در مدیریت همزمانی.
  - استفاده از `asyncio.run()` برای اجرای برنامه‌های غیرهمزمان.
- **استفاده از `async` و `await`**:
  - معرفی و نحوه استفاده از `async` برای تعریف توابع غیرهمزمان.
  - استفاده از `await` برای فراخوانی توابع غیرهمزمان و بلوکه کردن برنامه تا دریافت نتیجه.
  - مدیریت چندین کار غیرهمزمان با استفاده از `asyncio.gather()` و `asyncio.create_task()`.
  - استفاده از `async with` برای مدیریت منابع در توابع غیرهمزمان.
  - مدیریت خطاها و استثناها در توابع غیرهمزمان با استفاده از `try-except`.
  - مقایسه عملکرد `asyncio` با استفاده از `Threading` و `Multiprocessing` در پردازش‌های IO-bound و CPU-bound.
- **کار با ورودی/خروجی (I/O) غیرهمزمان**:
  - استفاده از `asyncio` برای انجام عملیات I/O مانند خواندن و نوشتن به فایل‌ها، برقراری ارتباط شبکه‌ای، و درخواست‌های HTTP به‌صورت غیرهمزمان.
  - معرفی کتابخانه‌هایی مانند `aiohttp` برای ارسال درخواست‌های HTTP غیرهمزمان.
  - اجرای عملیات I/O موازی بدون بلوکه کردن برنامه.
- **زمان‌بندی و مدیریت Taskها در Asyncio**:
  - استفاده از `asyncio.sleep()` برای تاخیر در توابع غیرهمزمان.
  - اجرای Taskهای غیرهمزمان با استفاده از `asyncio.create_task()`.
  - مدیریت زمان‌بندی با استفاده از `asyncio.wait()` و `asyncio.as_completed()` برای انجام Taskها به ترتیب و همزمان.
- **استفاده از منابع همزمان با مدیریت امنیت**:
  - مدیریت `race condition` و هماهنگی در توابع غیرهمزمان با استفاده از `asyncio.Lock` و `asyncio.Semaphore`.

#### 3. **بهینه‌سازی عملکرد و مقیاس‌پذیری در برنامه‌های همزمان**

- مقایسه عملکرد پردازش‌ها در حالت همزمان و غیرهمزمان

  - بررسی عملکرد برنامه‌های چندوظیفه‌ای با استفاده از `Threading`, `Multiprocessing` و `Asyncio` در سناریوهای مختلف.
  - انتخاب بهترین روش برای انجام عملیات I/O-bound و CPU-bound.

- استفاده از Queue‌ها و Synchronization Objects برای مدیریت منابع

  :

  - استفاده از `Queue` در `Multiprocessing` برای ارسال داده‌ها بین پردازش‌ها.
  - استفاده از `asyncio.Queue` برای ارسال داده‌ها در برنامه‌های غیرهمزمان.
  - استفاده از اشیاء همگام‌سازی مانند `Lock`, `Event`, `Semaphore` برای جلوگیری از شرایط هم‌زمانی (Concurrency issues).





------

### بخش 10: تست و دیباگ (Testing & Debugging)

#### 1. **تست‌نویسی با `unittest`**

- نوشتن تست‌های واحد
  - معرفی مفهوم تست واحد و اهمیت آن در برنامه‌نویسی.
  - استفاده از `unittest.TestCase` برای تعریف کلاس‌های تست.
  - نوشتن متدهای تست با استفاده از `assertEqual()`, `assertTrue()`, `assertFalse()`, `assertRaises()` و دیگر متدهای بررسی.
  - ساختار فایل‌های تست و تقسیم‌بندی آنها.
  - اجرای تست‌ها با استفاده از `unittest.main()` و بررسی نتایج تست‌ها.
- استفاده از mock و assert در تست‌ها
  - معرفی مفهوم mocking در تست‌نویسی.
  - استفاده از `unittest.mock` برای ایجاد اشیاء mock و تست وابستگی‌ها.
  - استفاده از `assert` برای تایید رفتار صحیح کد.
  - نحوه تست کدهای با وابستگی‌های خارجی مانند پایگاه داده یا APIها با استفاده از mock.
  - بررسی خطاها و استثناها در تست‌ها با استفاده از `assertRaises()`.

#### 2. **استفاده از `pytest`**

- **معرفی `pytest` و کاربرد آن**:
  - تفاوت‌های `pytest` با `unittest` و مزایای استفاده از آن.
  - نصب و راه‌اندازی `pytest` در پروژه.
  - نوشتن تست‌های ساده با `pytest` و اجرا کردن آنها.
  - استفاده از `assert` در `pytest` برای بررسی نتایج.
- **نوشتن و اجرای تست‌ها با `pytest`**:
  - ساختار و سازمان‌دهی تست‌ها با `pytest`.
  - نوشتن تست‌های پارامتریک با استفاده از `@pytest.mark.parametrize`.
  - استفاده از `pytest fixtures` برای آماده‌سازی داده‌ها و منابع مورد نیاز قبل از اجرای تست‌ها.
  - اجرای تست‌ها با `pytest` و نمایش نتایج.
  - نحوه بررسی خروجی تست‌ها با استفاده از `pytest` و گزینه‌های مختلف آن مانند `-v` و `--maxfail`.
  - استفاده از `pytest` برای تست‌های غیرهمزمان (async) با `pytest-asyncio`.
- **گزارش‌گیری و خروجی‌های تست‌ها**:
  - تولید گزارش‌های تست با استفاده از گزینه‌های `pytest` مانند `--html` برای خروجی HTML و `--junitxml` برای خروجی XML.
  - استفاده از پلاگین‌های اضافی مانند `pytest-cov` برای بررسی پوشش کد (code coverage).

#### 3. **دیباگ کردن با `pdb`**

- استفاده از Debugger در پایتون

  - معرفی کتابخانه `pdb` (Python Debugger) و کاربرد آن در فرآیند دیباگ.

  - قرار دادن `import pdb; pdb.set_trace()` برای شروع دیباگ و قرار دادن نقطه توقف (breakpoint).

  - استفاده از دستوراتی مانند `n` (next), `s` (step), `c` (continue) و `q` (quit) برای حرکت در کد و بررسی وضعیت.

  - بررسی و تغییر مقادیر متغیرها در حین اجرای برنامه با استفاده از `pdb`.

  - استفاده از `pdb` برای بررسی استثناها و پیگیری خطاها در کد.

    

- قرار دادن breakpointها و بررسی مقادیر متغیرها

  - قرار دادن breakpoint در نقاط مختلف کد برای توقف در آن نقاط.

  - بررسی مقادیر متغیرها در حین اجرای کد با استفاده از دستورات `pdb` مانند `print` و `pdb.set_trace()`.

  - استفاده از `continue` برای ادامه اجرای کد بعد از بررسی مقادیر.

    

- دیباگ کدهای غیرهمزمان و Multi-threading

  - نحوه استفاده از `pdb` در کدهای غیرهمزمان (async) و مدیریت multi-threading در حین دیباگ.
  - استفاده از `pdb` برای دیباگ کردن کدهای با چندین پردازش و نخ در `multiprocessing` و `threading`.





-----------



### بخش 11: مهارت‌های پیشرفته پایتون

#### 1. **حل مسائل الگوریتمی و داده‌ساختاری**

- تمرینات و مسائل الگوریتمی
  - حل مسائل الگوریتمی متداول مانند جستجو (Search algorithms)، مرتب‌سازی (Sorting algorithms)، جداول هش (Hash tables)، و گراف‌ها (Graphs).
  - معرفی الگوریتم‌های جستجوی باینری، جستجو در عمق (DFS) و جستجو در عرض (BFS) برای حل مسائل.
  - استفاده از تکنیک‌های مرتب‌سازی همچون QuickSort و MergeSort و بررسی پیچیدگی زمانی آن‌ها.
  - کار با داده‌ساختارهای مختلف مثل لیست‌ها، دیکشنری‌ها، مجموعه‌ها و صف‌ها.
- استفاده از الگوریتم‌های مختلف برای حل مسائل پیچیده
  - استفاده از الگوریتم‌های تقسیم و غلبه (Divide and Conquer) برای حل مسائل پیچیده.
  - به‌کارگیری الگوریتم‌های پویا (Dynamic Programming) و برنامه‌نویسی بازگشتی برای مسائل بهینه‌سازی.
  - کاربرد الگوریتم‌های گراف‌ها (مثل Dijkstra و Floyd-Warshall) برای حل مسائل مرتبط با مسیرهای کوتاه در شبکه‌ها.

#### 2. **کدنویسی بهینه و مدیریت حافظه**

- نوشتن کد بهینه از لحاظ زمان و حافظه
  - تحلیل پیچیدگی زمانی و فضایی الگوریتم‌ها با استفاده از مفاهیم Big O notation.
  - استفاده از الگوریتم‌های بهینه برای حل مسائل با داده‌های بزرگ (مثل الگوریتم‌های Greedy و Backtracking).
  - بهینه‌سازی حافظه با استفاده از ساختارهای داده مناسب.
- استفاده از ساختارهای داده مناسب
  - انتخاب ساختار داده بهینه برای حل مسئله خاص (مثلاً انتخاب بین لیست، دیکشنری، مجموعه و صف برای نیازهای خاص).
  - کاربرد درخت‌ها، گراف‌ها و جداول هش در مسائل پیچیده‌تر.
- پروفایلینگ کد
  - استفاده از ابزارهای پروفایلینگ مانند `cProfile` برای شناسایی بخش‌های کند برنامه.
  - تحلیل نتایج پروفایلینگ و بهینه‌سازی عملکرد کد.
  - استفاده از `timeit` برای مقایسه زمان اجرای توابع مختلف.

#### 3. **استفاده از ابزارهای پیشرفته پایتون**

- Decorators
  - معرفی مفهوم Decorator و کاربرد آن برای تغییر یا بهبود رفتار توابع و کلاس‌ها.
  - نوشتن و استفاده از decoratorها برای افزودن ویژگی‌های اضافی به توابع بدون تغییر در کد اصلی.
  - کاربرد Decorator برای مدیریت اعتبارسنجی، لاگ‌کردن و مجوزها.
- Context Managers
  - استفاده از Context Manager برای مدیریت منابع مانند فایل‌ها، اتصالات پایگاه داده یا شبکه.
  - تعریف Context Managerهای سفارشی با استفاده از `with` و متدهای `__enter__` و `__exit__`.
  - مثال‌های کاربردی از استفاده `with` برای باز و بسته کردن فایل‌ها یا مدیریت تراکنش‌های پایگاه داده.
- Generators و Iterators
  - معرفی Generators به عنوان راهی برای تولید داده‌ها به صورت lazy (تنبل) و بدون بارگذاری همه داده‌ها در حافظه.
  - استفاده از `yield` برای ساختن generatorها.
  - بررسی تفاوت‌های بین iterators و generators و مزایای استفاده از آن‌ها در برنامه‌های با داده‌های بزرگ.
  - مثال‌هایی از استفاده از Generators در پردازش داده‌های متنی، فایل‌ها یا شبکه.

#### 4. **برنامه‌نویسی موازی و همزمان**

- استفاده از `asyncio` برای برنامه‌نویسی غیرهمزمان
  - ایجاد کدهای غیرهمزمان با استفاده از `async`, `await`, و `asyncio`.
  - نحوه استفاده از `asyncio` برای انجام عملیات ورودی/خروجی بدون مسدود کردن جریان اصلی برنامه.
- استفاده از multiprocessing و threading
  - تفاوت‌های بین `threading` و `multiprocessing` و انتخاب مناسب‌ترین روش برای پردازش‌های موازی.
  - بهینه‌سازی برنامه‌ها برای انجام چندین پردازش به طور همزمان.

#### 5. **متدهای پیشرفته در مدیریت استثناها**

- ایجاد استثناهای سفارشی
  - تعریف کلاس‌های استثنا و استفاده از آن‌ها در برنامه‌ها.
  - به‌کارگیری استثناهای سفارشی برای مدیریت خطاهای خاص در سیستم‌های بزرگتر.
- استفاده از `try`, `except`, `else`, `finally`
  - استفاده از `else` و `finally` برای مدیریت رفتار برنامه در مواقعی که خطا رخ نمی‌دهد یا پس از وقوع خطا.

#### 6. **کدهای کارآمد و قابل تست**

- اهمیت نوشتن کد قابل تست
  - استفاده از تست‌های واحد برای بررسی بخش‌های مختلف کد.
  - طراحی سیستم‌هایی که بتوان به راحتی آن‌ها را آزمایش و اصلاح کرد.



